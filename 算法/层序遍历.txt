惭愧，这道简简单单的层序遍历，花了我好几天的时间才最终做出来，我可真是个小宝贝啊。
最主要自己对于二叉树这些都忘记的差不多了，花了一部分时间来温习二叉树。
树，不过是传递和存储信息的数据结构。
用树枝传递控制信息，用节点保存信息，最终就构成了这样的一个数据结构。
既然这样，那么他的使用方法无非是用某个方法来查找某个特定的数。
说到查找，对于树枝没有传递信息的，我们一般选择遍历。
遍历的方法就很重要了，因为这关系着运行时间。（如果有特殊需求的话，我们就使用特定的方法）
遍历无非是前中后序（以节点本身来说的）、层序。
这些遍历，我们通常会使用的是通过递归实现，递归就不写了，也不是重点。
那么如果是非递归该怎么写，我们可以简单的将递归使用的栈结构显式化，即直接使用栈来进行迭代即可。
就像本题，层序遍历就是将栈变成队列，即可满足。
如果我们不想构造额外的空间，那么可以利用现有的空间进行。
如本题，带了next指针，那么我们可以利用该指针做文章。直接使用next进行迭代，通过上一层可以得知下一层的next关系，再利用下一层的next关系判断下下层即可。
我们使用几个标记节点，now:标记当前位置 nextone ：标记下一层位置 start :标记下一层初始位置（因为每层最后一个next= NULL）
思路比较简单，我在中间内层循环的边界值卡了很久，后来灵机一动想到了直接判断now==null，因为now是需要迭代的,now = now ->next ，会一直持续到该层结束，而恰好最后指向的就是Next。
大体思路
外层循环（是否有下一层）
{
内层循环（该层是否结束）
{
判断是当前节点的左子节点还是又子节点
判断当前子节点是否有有效值
判断该子节点是否是初始节点
}
}
